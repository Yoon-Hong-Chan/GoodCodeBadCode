## 4.2 견고성 vs 실패
- 오류 발생 시, 다음 중 하나 선택해야함
  - 실패, 더 높은 코드 계층이 오류 처리 또는 전체 프로그램 작동 멈춤
  - 오류 처리 후 계속 진행(견고한 코드)

## 4.2.1 신속하게 실패하라
- 가능한 한 문제의 실제 발생 지점으로부터 가까운 곳에서 오류를 나타내기 ☞ 개발자가 대처(복구 or 문제 파악)가 용이함
- 만약 실패나 오류를 보여주지 않는다면? 누적된 이상현상으로 더 많은 수고가 드는 상황을 만듬

## 4.2.2 요란하게 실패하라
- 프로그램 상 복구할 수 없는 오류 발생 ☞ 개발자의 실수일 가능성이 큼
- 다음과 같이 처리하여 개발자에게 오류가 발생하였다는 것을 알림
  - 예외를 발생해 프로그램 중단
  - 오류 메시지를 기록 ☞ 개발자가 부지런해야함...
- 코드가 신속하고 요란하게 실패할 수록 개발 및 테스트 과정에서 발견할 가능성이 높고, 그렇지 않더라도 그 후 확인 쉬움

## 4.2.3 복구 가능성의 범위
- 소프트웨어는 견고한게 좋음, But 오류를 알아차리지 못한 시스템이 되어선 안됨
  - 견고함과 요란스러운 실패는 양립 못할때가 많음
- 이에 대한 해결책은 견고하게 하고, 오류가 발생하는 부분에서 기록하여 개발자가 인지하여 대처할 수 있게함
- 모든 유형의 오류를 기록하는 것은 극도로 주의 -> 진입점이나 독립적인 곳에 기록(?)... 이해가 잘...

## 4.2.4 오류를 숨기지 않음
- 코드의 독립적이거나 중요하지 않은 부분을 분리하면 견고한 시스템 구축 가능 -> ? 아마 중요하지 않은 부분을 견고하게 하고 기록만으로 이해함
- 중요하거나, 낮은 계층에서 오류가 발생함에도 계속 진행하는 소프트웨어는? 의도한대로 작동하지 않고, 개발자가 문제 인식 못할 수 있음
- 오류를 숨기는 것은 복구할 수 있는 오류와 복구할 수 없는 오류 모두에 문제를 야기시킴
- 오류 발생 숨기는 몇가지 방법
  - 기본값 반환: 이상 유무 전달 없이 기본 값 전달은 사용하는 입장에서 이상 유무 확인이 힘듬
  - 널 객체 패턴: 빈 리스트 반환과 같은 거 부터 전체 클래스 구현과 같은 부분, 기본값과 유사하지만 확장된 객체를 다룸
  - 아무것도 하지 않음(void): 문제 전달 없이 그냥 지나침 -> 사용하는 입장에서 처리되었다고 오판단